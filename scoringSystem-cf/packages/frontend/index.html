<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Â∞àÊ°àË©ïÂàÜÁ≥ªÁµ±</title>

  <!-- Favicon (will be dynamically updated) -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">

  <!-- Google Fonts - Huninn Á≤âÂúì (ËÉåÊôØËºâÂÖ•Ôºå‰∏çÈòªÂ°ûÊ∏≤Êüì) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Huninn&display=swap" rel="stylesheet">

  <!-- Font Awesome CSS - ‰ΩøÁî® preload ÈÅøÂÖç render blocking -->
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></noscript>

  <!-- KaTeX CSS - ‰ΩøÁî® preload ÈÅøÂÖç render blocking -->
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" as="style" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"></noscript>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js" integrity="sha512-LQNxIMR5rXv7o+b1l8+N1EZMfhG7iFZ9HhnbJkTp4zjNr5Wvst75AqUeFDxeRUa7l5vEDyUiAip//r+EFLLCyA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- D3.js Library - ‰ΩøÁî® Cloudflare cdnjs -->
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Cloudflare Turnstile -->
  <script src="https://challenges.cloudflare.com/turnstile/v0/api.js?render=explicit" async></script>
  <script>
    // Áõ£ËÅΩ Turnstile API ËºâÂÖ•ÁãÄÊÖã
    window.turnstileLoaded = false;
    window.onTurnstileLoad = function() {
      window.turnstileLoaded = true;
      console.log('Turnstile API loaded from onload callback');
    };
  </script>

  <style>
    /* Emoji Wave Loading Animation Styles */
    #initial-loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: #f5f5f5;
      z-index: 9999;
      transition: opacity 0.5s ease-out;
    }

    #initial-loading h3 {
      color: #333;
      font-family: 'Huninn', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      font-size: 20px;
      font-weight: 500;
      margin-bottom: 30px;
    }

    #emoji-wave-container {
      position: relative;
      width: 400px;
      height: 120px;
      animation: wave-oscillate 3s ease-in-out infinite;
    }

    @keyframes wave-oscillate {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(8px); }
    }

    .emoji {
      position: absolute;
      font-size: 28px;
      opacity: 0;
      transform: scale(0);
      transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      user-select: none;
      pointer-events: none;
    }

    .emoji.visible {
      opacity: 1;
      transform: scale(1);
    }

    #loading-text {
      text-align: center;
      color: #666;
      font-family: 'Huninn', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      font-size: 14px;
      margin-top: 25px;
    }

    /* Fallback for older browsers */
    .loading-fallback {
      display: none;
    }

    @supports not (offset-path: path('M0,0')) {
      #emoji-wave-container {
        display: none;
      }
      .loading-fallback {
        display: block;
        font-size: 24px;
        animation: pulse 1.5s ease-in-out infinite;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
    }
  </style>
</head>
<body>
  <!-- Initial Loading Screen with Emoji Wave -->
  <div id="initial-loading">
    <h3>Â∞àÊ°àË©ïÂàÜÁ≥ªÁµ±</h3>

    <!-- Emoji Wave Container -->
    <div id="emoji-wave-container">
      <!-- Emojis will be dynamically generated here -->
    </div>

    <!-- Fallback for unsupported browsers -->
    <div class="loading-fallback">üöÄ</div>

    <!-- Loading Text -->
    <p id="loading-text">ËºâÂÖ•‰∏≠...</p>
  </div>

  <div id="app"></div>

  <script>
    // ÂæûÂæåÁ´ØÂèñÂæóÁ≥ªÁµ±Ê®ôÈ°å
    (async function loadSystemTitle() {
      try {
        const response = await fetch('/api/system/info');
        const result = await response.json();
        if (result.success && result.data?.systemTitle) {
          const title = result.data.systemTitle;
          // Êõ¥Êñ∞ËºâÂÖ•È†Å h3
          const h3 = document.querySelector('#initial-loading h3');
          if (h3) h3.textContent = title;
          // Êõ¥Êñ∞ÁÄèË¶ΩÂô®Ê®ôÁ±§
          document.title = title;
        }
      } catch (e) {
        // API Â§±ÊïóÊôÇ‰øùÊåÅ hardcode ÁöÑ "Â∞àÊ°àË©ïÂàÜÁ≥ªÁµ±"
      }
    })();

    // Emoji Wave Loading Animation
    (function() {
      // 6 theme groups with 5 emojis each (30 total)
      const EMOJI_GROUPS = {
        achievement: ['üèÜ', 'ü•á', 'ü•à', 'ü•â', '‚≠ê'],
        learning:    ['üéì', 'üìö', 'üìñ', 'üìù', 'üìì'],
        work:        ['üíº', 'üíª', 'üè¢', 'üìã', 'üìä'],
        progress:    ['üöÄ', '‚è≥', 'üìÖ', 'üéØ', 'üìà'],
        teamwork:    ['üë•', 'üë´', 'ü§ù', 'üí¨', 'üí°'],
        quality:     ['‚úÖ', '‚ùå', '‚úç', 'üìå', 'üîó']
      };

      // Pick 20 random emojis (3 from each group + 2 extra)
      function pickRandomEmojis() {
        const picked = [];
        const allEmojis = [];

        // Pick 3 from each group
        Object.values(EMOJI_GROUPS).forEach(group => {
          const shuffled = [...group].sort(() => Math.random() - 0.5);
          picked.push(...shuffled.slice(0, 3));
          allEmojis.push(...group);
        });

        // Pick 2 more from remaining emojis
        const remaining = allEmojis.filter(e => !picked.includes(e));
        const extraTwo = remaining.sort(() => Math.random() - 0.5).slice(0, 2);
        picked.push(...extraTwo);

        // Shuffle final array
        return picked.sort(() => Math.random() - 0.5);
      }

      // Generate random wave path with varying peaks and valleys
      function generateWavePath(width, height, segments) {
        const points = [];
        const segmentWidth = width / segments;

        // Start point
        points.push({ x: 0, y: height / 2 });

        // Generate random control points for each segment
        for (let i = 1; i <= segments; i++) {
          const x = i * segmentWidth;
          // Random peak/valley (between 15% and 85% of height)
          const y = height * 0.15 + Math.random() * height * 0.7;
          points.push({ x, y });
        }

        // Build SVG path string using quadratic bezier curves
        let path = `M${points[0].x},${points[0].y}`;
        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1];
          const curr = points[i];
          const controlX = (prev.x + curr.x) / 2;
          const controlY = height * 0.15 + Math.random() * height * 0.7;
          path += ` Q${controlX},${controlY} ${curr.x},${curr.y}`;
        }

        return path;
      }

      // Calculate point position along the path at a given percentage
      function getPointOnPath(pathElement, percentage) {
        const length = pathElement.getTotalLength();
        const point = pathElement.getPointAtLength(length * percentage);
        return { x: point.x, y: point.y };
      }

      // State
      let emojiElements = [];
      let currentProgress = 0;
      let svgPath = null;

      // Initialize the emoji wave
      function initEmojiWave() {
        const container = document.getElementById('emoji-wave-container');
        if (!container) return;

        // Check if offset-path is supported (fallback already handled by CSS)
        const testEl = document.createElement('div');
        testEl.style.offsetPath = "path('M0,0')";
        const supportsOffsetPath = testEl.style.offsetPath !== '';

        if (!supportsOffsetPath) {
          console.log('offset-path not supported, using fallback');
          return;
        }

        const emojis = pickRandomEmojis();
        const width = 400;
        const height = 120;
        const segments = 8;

        // Create hidden SVG to compute path points
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.style.position = 'absolute';
        svg.style.visibility = 'hidden';
        svg.style.pointerEvents = 'none';

        const pathD = generateWavePath(width, height, segments);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathD);
        svg.appendChild(path);
        container.appendChild(svg);

        svgPath = path;

        // Create emoji elements positioned along the path
        emojis.forEach((emoji, index) => {
          const el = document.createElement('span');
          el.className = 'emoji';
          el.textContent = emoji;

          // Calculate position along path (evenly distributed)
          const percentage = index / (emojis.length - 1);
          const point = getPointOnPath(path, percentage);

          el.style.left = `${point.x - 14}px`; // Center emoji (28px / 2)
          el.style.top = `${point.y - 14}px`;

          container.appendChild(el);
          emojiElements.push(el);
        });
      }

      // Update progress and show emojis
      function updateProgress(percent) {
        currentProgress = Math.min(100, Math.max(0, percent));
        const visibleCount = Math.floor(currentProgress / 5); // 20 emojis, each 5%

        emojiElements.forEach((el, index) => {
          if (index < visibleCount && !el.classList.contains('visible')) {
            // Add slight delay for staggered animation
            setTimeout(() => {
              el.classList.add('visible');
            }, index * 30);
          }
        });

        // Update loading text based on progress
        const loadingText = document.getElementById('loading-text');
        if (loadingText) {
          if (percent < 25) {
            loadingText.textContent = 'ËºâÂÖ•‰∏≠...';
          } else if (percent < 50) {
            loadingText.textContent = 'ËºâÂÖ•Ê®£Âºè...';
          } else if (percent < 75) {
            loadingText.textContent = 'ÂàùÂßãÂåñÊáâÁî®...';
          } else if (percent < 100) {
            loadingText.textContent = 'Âç≥Â∞áÂÆåÊàê...';
          } else {
            loadingText.textContent = 'ËºâÂÖ•ÂÆåÊàê';
          }
        }
      }

      // Initialize on page load
      initEmojiWave();

      // Start initial progress animation
      setTimeout(() => updateProgress(10), 100);
      setTimeout(() => updateProgress(25), 300);

      // CSS loaded (DOMContentLoaded)
      document.addEventListener('DOMContentLoaded', () => {
        updateProgress(50);
      });

      // Vue app loading progress (called from main.ts)
      window.appLoadingProgress = function() {
        updateProgress(75);
      };

      // Hide loading screen (called when app is ready)
      window.hideInitialLoading = function() {
        updateProgress(100);

        const initialLoading = document.getElementById('initial-loading');
        if (initialLoading) {
          setTimeout(() => {
            initialLoading.style.opacity = '0';
            setTimeout(() => {
              initialLoading.remove();
            }, 500);
          }, 400);
        }
      };
    })();
  </script>

  <script type="module" src="/src/main.ts"></script>
</body>
</html>
