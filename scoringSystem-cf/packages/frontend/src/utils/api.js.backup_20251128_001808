/**
 * API Client for Cloudflare Workers Backend
 * Migrated from Google Apps Script to Cloudflare Workers
 *
 * Key Changes:
 * - google.script.run â†’ fetch API
 * - PropertiesService Session â†’ JWT Token
 * - Automatic session extension via lastActivityTime
 */

import { handleApiError } from './errorHandler'
import { getCachedClientIP } from './ip'

class APIClient {
  constructor() {
    // é–‹ç™¼ç’°å¢ƒä½¿ç”¨ç›¸å°è·¯å¾‘ï¼ˆé€šé Vite ä»£ç†ï¼‰
    // ç”Ÿç”¢ç’°å¢ƒä½¿ç”¨å®Œæ•´ URL
    this.baseURL = import.meta.env.VITE_API_URL || ''

    // For development: allow custom API URL
    if (typeof window !== 'undefined' && window.CLOUDFLARE_API_URL) {
      this.baseURL = window.CLOUDFLARE_API_URL
    }
  }

  /**
   * Get current JWT token from localStorage
   */
  getToken() {
    return localStorage.getItem('sessionId') // Keep same key name for compatibility
  }

  /**
   * Save JWT token to localStorage
   */
  saveToken(token) {
    localStorage.setItem('sessionId', token)
  }

  /**
   * Remove JWT token (logout)
   */
  clearToken() {
    localStorage.removeItem('sessionId')
    localStorage.removeItem('sessionExpiryTime')
    localStorage.removeItem('sessionTimeout')
  }

  /**
   * Handle session information from backend
   * Note: With JWT, session is extended automatically on each request
   */
  handleSessionInfo(sessionInfo) {
    if (!sessionInfo) return

    if (!sessionInfo.isValid) {
      // Session invalid, clear local storage
      this.clearToken()
      console.warn('âš ï¸ Session ç„¡æ•ˆï¼š', sessionInfo.message)

      // Redirect to login page
      if (window.location.hash !== '#/login') {
        window.location.hash = '#/login'
      }
      return
    }

    // Session valid, update local info
    const remainingMinutes = Math.floor(sessionInfo.remainingTime / (1000 * 60))
    const remainingHours = Math.floor(remainingMinutes / 60)

    // Show warning if less than 5 minutes remaining
    if (remainingMinutes < 5 && remainingMinutes > 0) {
      console.warn(`âš ï¸ Session å°‡åœ¨ ${remainingMinutes} åˆ†é˜å¾ŒéæœŸ`)

      // Trigger global event for UI warning
      if (typeof window.showSessionWarning === 'function') {
        window.showSessionWarning(remainingMinutes)
      }
    }

    // Update expiry time info
    if (sessionInfo.expiryTime) {
      localStorage.setItem('sessionExpiryTime', sessionInfo.expiryTime.toString())
    }

    // Session timeout is managed by JWT - no need for manual tracking
    if (sessionInfo.sessionTimeout) {
      localStorage.setItem('sessionTimeout', sessionInfo.sessionTimeout.toString())
    }

    // Log detailed time info
    if (remainingHours > 0) {
      console.log(`âœ… Session å·²å»¶é•·ï¼Œå‰©é¤˜æ™‚é–“ï¼š${remainingHours} å°æ™‚ ${remainingMinutes % 60} åˆ†é˜`)
    } else {
      console.log(`âœ… Session å·²å»¶é•·ï¼Œå‰©é¤˜æ™‚é–“ï¼š${remainingMinutes} åˆ†é˜`)
    }
  }

  /**
   * Core API call method using fetch
   */
  async call(endpoint, data = {}, method = 'POST', options = {}) {
    const { silent = false } = options

    // Get client IP for auth-related operations
    const needsIP = endpoint.includes('/auth/') || endpoint.includes('login') || endpoint.includes('register')
    if (needsIP && !data.clientIP) {
      try {
        const ipInfo = await getCachedClientIP()
        data.clientIP = ipInfo.ip || 'unknown'
        data.city = ipInfo.city
        data.country = ipInfo.country
      } catch (error) {
        console.warn('Failed to get client IP:', error)
        data.clientIP = 'unknown'
      }
    }

    try {
      // Build fetch options
      const fetchOptions = {
        method: method,
        headers: {
          'Content-Type': 'application/json'
        }
      }

      // Add Authorization header if token exists
      const token = this.getToken()
      if (token) {
        fetchOptions.headers['Authorization'] = `Bearer ${token}`
      }

      // Add body for POST/PUT requests
      if (method !== 'GET' && method !== 'DELETE') {
        fetchOptions.body = JSON.stringify(data)
      }

      // Build URL with query params for GET requests
      let url = `${this.baseURL}${endpoint}`
      if (method === 'GET' && Object.keys(data).length > 0) {
        const params = new URLSearchParams(data)
        url += `?${params.toString()}`
      }

      // Make fetch request
      const response = await fetch(url, fetchOptions)

      // Parse JSON response
      let result
      try {
        result = await response.json()
      } catch (jsonError) {
        console.error('Failed to parse JSON response:', jsonError)
        throw new Error('Invalid JSON response from server')
      }

      // Check response format
      if (!result || typeof result !== 'object') {
        throw new Error('Invalid response format from backend')
      }

      // Handle token refresh (sliding expiration)
      // Check for new token in response header
      const newToken = response.headers.get('X-New-Token')
      if (newToken) {
        console.log('ğŸ”„ Token refreshed (sliding expiration)')
        this.saveToken(newToken)
      }

      // Handle session info from response
      if (result.session) {
        this.handleSessionInfo(result.session)
      }

      // Handle new token from login/register
      if (result.success && result.token) {
        this.saveToken(result.token)
      }

      // Handle API error responses
      if (!response.ok || !result.success) {
        // Don't show errors for auth validation and system info endpoints (normal during initial load)
        const isAuthValidation = endpoint.includes('/auth/current-user') ||
                                endpoint.includes('/auth/validate') ||
                                endpoint.includes('/auth/session') ||
                                endpoint.includes('/system/info') ||
                                endpoint.includes('/system/turnstile-config')

        if (!silent && !isAuthValidation) {
          const action = this.getActionDescription(endpoint, method)
          handleApiError(result, action)
        }
      }

      return result

    } catch (error) {
      // Network or system error
      console.error('API call error:', error)

      // åˆ¤æ–·éŒ¯èª¤é¡å‹
      const isConnectionError = error.message === 'Failed to fetch' ||
                               error.name === 'TypeError' ||
                               error.message.includes('fetch')

      const isServiceUnavailable = error.status === 503 ||
                                   error.message.includes('503')

      // ç‰¹æ®Šè™•ç†ï¼šå†·å•Ÿå‹•æˆ–æœå‹™æš«æ™‚ä¸å¯ç”¨
      if (isConnectionError || isServiceUnavailable) {
        console.warn('âš ï¸ å¾Œç«¯æœå‹™æš«æ™‚ä¸å¯ç”¨ï¼ˆå¯èƒ½æ˜¯å†·å•Ÿå‹•ï¼‰ï¼Œå°‡è‡ªå‹•é‡è©¦')

        // ä¸é¡¯ç¤ºéŒ¯èª¤çµ¦ç”¨æˆ¶ï¼Œè®“ TanStack Query è™•ç†é‡è©¦
        return {
          success: false,
          error: {
            code: 'SERVICE_UNAVAILABLE',
            message: 'æœå‹™æš«æ™‚ä¸å¯ç”¨',
            retryable: true // æ¨™è¨˜ç‚ºå¯é‡è©¦
          }
        }
      }

      // å…¶ä»–ç¶²çµ¡éŒ¯èª¤ï¼šé¡¯ç¤ºçµ¦ç”¨æˆ¶
      if (!silent) {
        const action = this.getActionDescription(endpoint, method)
        handleApiError({
          success: false,
          error: {
            code: 'NETWORK_ERROR',
            message: error.message || 'ç¶²è·¯é€£ç·šéŒ¯èª¤'
          }
        }, action)
      }

      return {
        success: false,
        error: {
          code: 'NETWORK_ERROR',
          message: error.message || 'ç¶²è·¯éŒ¯èª¤ï¼Œè«‹é‡è©¦'
        }
      }
    }
  }

  /**
   * API call with authentication (requires JWT token)
   */
  async callWithAuth(endpoint, data = {}, method = 'POST', options = {}) {
    const token = this.getToken()

    if (!token) {
      const errorResponse = {
        success: false,
        error: {
          code: 'NO_SESSION',
          message: 'å°šæœªç™»å…¥ï¼Œè«‹å…ˆç™»å…¥'
        }
      }

      // Don't show error for missing session (normal initial state)
      return errorResponse
    }

    // Note: Token is added in call() via Authorization header
    // Keep sessionId in body for backward compatibility
    return this.call(endpoint, { ...data, sessionId: token }, method, options)
  }

  /**
   * Get action description for error messages
   */
  getActionDescription(endpoint, method) {
    const actionMap = {
      '/auth/login': 'ç™»å…¥',
      '/auth/logout': 'ç™»å‡º',
      '/auth/register': 'è¨»å†Š',
      '/auth/change-password': 'ä¿®æ”¹å¯†ç¢¼',
      '/auth/validate': 'é©—è­‰æœƒè©±',
      '/auth/current-user': 'é©—è­‰æœƒè©±',
      '/auth/session': 'é©—è­‰æœƒè©±',
      '/users/profile': method === 'GET' ? 'ç²å–å€‹äººè³‡æ–™' : 'æ›´æ–°å€‹äººè³‡æ–™',
      '/users/avatar/update': 'æ›´æ–°é ­åƒ',
      '/projects/create': 'å»ºç«‹å°ˆæ¡ˆ',
      '/projects/update': 'æ›´æ–°å°ˆæ¡ˆ',
      '/projects/delete': 'åˆªé™¤å°ˆæ¡ˆ',
      '/projects/core': 'è¼‰å…¥å°ˆæ¡ˆè³‡æ–™',
      '/projects/list': 'è¼‰å…¥å°ˆæ¡ˆåˆ—è¡¨',
      '/projects/list-with-stages': 'è¼‰å…¥å°ˆæ¡ˆåˆ—è¡¨',
      '/submissions/submit': 'æäº¤å ±å‘Š',
      '/rankings/submit': 'æäº¤æ’å',
      '/rankings/stage-rankings': 'ç²å–éšæ®µæ’å',
      '/rankings/teacher-vote-history': 'ç²å–æ•™å¸«æŠ•ç¥¨æ­·å²',
      '/comments/create': 'ç™¼è¡¨è©•è«–',
      '/comments/ranking': 'è©•è«–æŠ•ç¥¨',
      '/comments/rankings': 'ç²å–è©•è«–æ’å',
      '/comments/stage-rankings': 'ç²å–éšæ®µè©•è«–æ’å',
      '/comments/settlement-analysis': 'ç²å–è©•è«–è¨ˆç¥¨åˆ†æ',
      '/wallets/transactions': 'è¼‰å…¥äº¤æ˜“è¨˜éŒ„',
      '/groups/create': 'å»ºç«‹ç¾¤çµ„',
      '/groups/update': 'æ›´æ–°ç¾¤çµ„',
      '/groups/details': 'è¼‰å…¥ç¾¤çµ„è©³æƒ…',
      '/groups/add-member': 'æ–°å¢ç¾¤çµ„æˆå“¡',
      '/groups/remove-member': 'ç§»é™¤ç¾¤çµ„æˆå“¡',
      '/stages/create': 'å»ºç«‹éšæ®µ',
      '/stages/update': 'æ›´æ–°éšæ®µ',
      // DISABLED: '/tags/create': 'å»ºç«‹æ¨™ç±¤',
      // DISABLED: '/tags/update': 'æ›´æ–°æ¨™ç±¤',
      '/invitations/generate': 'ç”Ÿæˆé‚€è«‹ç¢¼',
      '/system/logs': 'ç²å–ç³»çµ±æ—¥èªŒ',
      '/system/logs/stats': 'ç²å–æ—¥èªŒçµ±è¨ˆ',
      '/system/logs/archive': 'æ—¥èªŒæ­¸æª”'
    }

    return actionMap[endpoint] || 'æ“ä½œ'
  }

  // ========== Authentication APIs ==========

  async register(userData) {
    return this.call('/auth/register', userData)
  }

  async logout() {
    const result = await this.callWithAuth('/auth/logout')
    if (result.success) {
      this.clearToken()
    }
    return result
  }

  async validateSession() {
    return this.callWithAuth('/auth/validate')
  }

  async changePassword(oldPassword, newPassword) {
    return this.callWithAuth('/auth/change-password', { oldPassword, newPassword })
  }

  async checkEmailAvailability(email) {
    return this.call('/auth/check-email', { email }, 'GET')
  }

  // ========== Comment APIs ==========

  async createComment(projectId, stageId, content, parentCommentId = null) {
    return this.callWithAuth('/comments/create', {
      projectId,
      commentData: {
        stageId,
        content,
        parentCommentId
      }
    })
  }

  async createReply(projectId, stageId, content, parentCommentId) {
    return this.createComment(projectId, stageId, content, parentCommentId)
  }

  async getStageComments(projectId, stageId, excludeTeachers = false) {
    return this.callWithAuth('/comments/stage', {
      projectId,
      stageId,
      excludeTeachers
    })
  }

  async submitCommentRanking(projectId, stageId, rankingData) {
    return this.callWithAuth('/comments/ranking', {
      projectId,
      stageId,
      rankingData
    })
  }

  async getCommentRankings(projectId, stageId, commentId) {
    return this.callWithAuth('/comments/rankings', {
      projectId,
      stageId,
      commentId
    })
  }

  async getStageCommentRankings(projectId, stageId) {
    return this.callWithAuth('/comments/stage-rankings', {
      projectId,
      stageId
    })
  }

  async getCommentSettlementAnalysis(projectId, stageId) {
    return this.callWithAuth('/comments/settlement-analysis', {
      projectId,
      stageId
    })
  }

  async checkVotingEligibility(projectId, stageId) {
    return this.callWithAuth('/comments/voting-eligibility', {
      projectId,
      stageId
    })
  }

  async getCommentRankingHistory(projectId, stageId) {
    return this.callWithAuth('/comments/ranking-history', {
      projectId,
      stageId
    })
  }

  // ========== User APIs ==========

  async getUserProfile(userId = null) {
    return this.callWithAuth('/users/profile', { userId }, 'GET')
  }

  async updateUserProfile(updates) {
    return this.callWithAuth('/users/profile', updates, 'PUT')
  }

  // ========== Project APIs ==========

  async getProjectCore(projectId) {
    return this.callWithAuth('/projects/core', { projectId })
  }

  /**
   * Get project content (submissions and/or comments)
   *
   * @param {string} projectId - The project ID (UUID format required)
   * @param {string} stageId - The stage ID (UUID format required)
   * @param {string} contentType - Content type: 'all', 'submissions', or 'comments'
   * @param {boolean} excludeTeachers - Exclude teacher comments from results
   * @param {boolean} includeSubmitted - Include 'submitted' status submissions (default: only 'approved')
   *                                     When true: returns both approved AND submitted submissions
   *                                     When false: returns ONLY approved submissions
   * @param {boolean} excludeUserGroups - Exclude submissions from user's own groups
   * @returns {Promise<Object>} Response with submissions and/or comments
   *
   * @example
   * // For ProjectDetail-New: show all participating groups' latest submissions (approved + submitted)
   * const response = await apiClient.getProjectContent(projectId, stageId, 'submissions', false, true, false)
   *
   * @example
   * // For VoteResultModal: only show approved submissions, excluding voter's own group
   * const response = await apiClient.getProjectContent(projectId, stageId, 'submissions', false, false, true)
   *
   * @example
   * // For TeacherVoteModal: only show approved submissions for all groups
   * const response = await apiClient.getProjectContent(projectId, stageId, 'submissions', false, false, false)
   */
  async getProjectContent(
    projectId,
    stageId = null,
    contentType = 'all',
    excludeTeachers = false,
    includeSubmitted = false,
    excludeUserGroups = false
  ) {
    return this.callWithAuth('/projects/content', {
      projectId,
      stageId,
      contentType,
      excludeTeachers,
      includeSubmitted,
      excludeUserGroups
    })
  }

  async getProjectsList() {
    return this.callWithAuth('/projects/list')
  }

  async getProjectsListWithStages() {
    return this.callWithAuth('/projects/list-with-stages')
  }

  async createProject(projectData) {
    return this.callWithAuth('/projects/create', { projectData })
  }

  async updateProject(projectId, updates) {
    return this.callWithAuth('/projects/update', { projectId, updates })
  }

  async deleteProject(projectId) {
    return this.callWithAuth('/projects/delete', { projectId })
  }

  // ========== Project Viewer APIs ==========

  async listProjectViewers(projectId) {
    // Silent mode: don't show error messages for permission denied
    // Regular project members don't have permission to view the full viewer list
    // This is handled gracefully in useProjectRole.js
    return this.callWithAuth('/projects/viewers/list', { projectId }, 'POST', { silent: true })
  }

  async addProjectViewer(projectId, targetUserEmail, role) {
    return this.callWithAuth('/projects/viewers/add', {
      projectId,
      userEmail: targetUserEmail,  // Backend expects 'userEmail', not 'targetUserEmail'
      role
    })
  }

  async removeProjectViewer(projectId, targetUserEmail) {
    return this.callWithAuth('/projects/viewers/remove', {
      projectId,
      userEmail: targetUserEmail  // Backend expects 'userEmail', not 'targetUserEmail'
    })
  }

  async updateProjectViewerRole(projectId, targetUserEmail, newRole) {
    return this.callWithAuth('/projects/viewers/update-role', {
      projectId,
      userEmail: targetUserEmail,  // Backend expects 'userEmail', not 'targetUserEmail'
      role: newRole  // Backend expects 'role', not 'newRole'
    })
  }

  // ========== User Search APIs ==========

  async searchUsers(searchText) {
    return this.callWithAuth('/users/search', { query: searchText, limit: 50 })
  }

  // ========== Submission APIs ==========

  async submitReport(projectId, stageId, submissionData) {
    return this.callWithAuth('/submissions/submit', {
      projectId,
      stageId,
      submissionData
    })
  }

  async voteApproveGroupSubmission(projectId, stageId, submissionId, agree, comment = '') {
    return this.callWithAuth('/submissions/confirm-participation', {
      projectId,
      stageId,
      submissionId,
      agree,
      comment
    })
  }

  async getGroupSubmissionApprovalVotes(projectId, stageId, submissionId) {
    return this.callWithAuth('/submissions/participation-status', {
      projectId,
      stageId,
      submissionId
    })
  }

  async deleteSubmission(projectId, submissionId) {
    return this.callWithAuth('/submissions/delete', {
      projectId,
      submissionId
    })
  }

  async getStageSubmissions(projectId, stageId) {
    return this.callWithAuth('/submissions/list', {
      projectId,
      stageId
    })
  }

  async getSubmissionVersions(projectId, stageId, options = {}) {
    return this.callWithAuth('/submissions/versions', {
      projectId,
      stageId,
      options
    })
  }

  async getGroupStageVotingHistory(projectId, stageId, groupId = null) {
    return this.callWithAuth('/submissions/voting-history', {
      projectId,
      stageId,
      groupId
    })
  }

  async restoreSubmissionVersion(projectId, stageId, submissionId) {
    return this.callWithAuth('/submissions/restore', {
      projectId,
      stageId,
      submissionId
    })
  }

  // ========== Ranking/Voting APIs ==========

  async submitGroupRanking(projectId, stageId, rankingData) {
    return this.callWithAuth('/rankings/submit', {
      projectId,
      stageId,
      rankingData
    })
  }

  async voteOnRankingProposal(projectId, proposalId, agree, comment) {
    return this.callWithAuth('/rankings/vote', {
      projectId,
      proposalId,
      agree,
      comment
    })
  }

  async checkUserVotingEligibility(projectId, stageId) {
    return this.callWithAuth('/comments/voting-eligibility', {
      projectId,
      stageId
    })
  }

  async submitRankingVote(projectId, stageId, rankings) {
    return this.callWithAuth('/rankings/stage-vote', {
      projectId,
      stageId,
      rankings
    })
  }

  async getStageVotingStatus(projectId, stageId) {
    return this.callWithAuth('/rankings/voting-status', {
      projectId,
      stageId
    })
  }

  async submitTeacherRanking(projectId, stageId, rankings) {
    return this.callWithAuth('/rankings/teacher-vote', {
      projectId,
      stageId,
      rankings
    })
  }

  async getTeacherRankings(projectId, stageId) {
    return this.callWithAuth('/rankings/teacher-rankings', {
      projectId,
      stageId
    })
  }

  async submitTeacherComprehensiveVote(projectId, stageId, rankings) {
    return this.callWithAuth('/rankings/teacher-comprehensive-vote', {
      projectId,
      stageId,
      rankings
    })
  }

  // Get teacher ranking version history
  async getTeacherRankingVersions(projectId, stageId, rankingType) {
    return this.callWithAuth('/rankings/teacher-ranking-versions', {
      projectId,
      stageId,
      rankingType  // 'submission' | 'comment'
    })
  }

  async getStageRankingProposals(projectId, stageId) {
    return this.callWithAuth('/rankings/proposals', {
      projectId,
      stageId
    })
  }

  async getStageRankings(projectId, stageId) {
    return this.callWithAuth('/rankings/stage-rankings', {
      projectId,
      stageId
    })
  }

  // ========== Settlement APIs ==========

  async getStageSettlementRankings(projectId, stageId) {
    return this.callWithAuth('/settlement/stage-rankings', {
      projectId,
      stageId
    })
  }

  async getCommentSettlementRankings(projectId, stageId) {
    return this.callWithAuth('/settlement/comment-rankings', {
      projectId,
      stageId
    })
  }

  async getSettlementHistory(projectId, stageId, settlementType) {
    return this.callWithAuth('/settlement/history', {
      projectId,
      stageId,
      settlementType  // 'stage' | 'comment'
    })
  }

  async getSettlementDetails(projectId, stageId, settlementType) {
    return this.callWithAuth('/settlement/details', {
      projectId,
      stageId,
      settlementType
    })
  }

  // ========== Group Management APIs ==========

  async getProjectGroups(projectId, includeInactive = false) {
    return this.callWithAuth('/groups/list', {
      projectId,
      includeInactive
    })
  }

  async createGroup(projectId, groupData) {
    return this.callWithAuth('/groups/create', {
      projectId,
      groupData
    })
  }

  async updateGroup(projectId, groupId, updates) {
    return this.callWithAuth('/groups/update', {
      projectId,
      groupId,
      updates
    })
  }

  async deleteGroup(projectId, groupId) {
    return this.callWithAuth('/groups/delete', {
      projectId,
      groupId
    })
  }

  async getGroupDetails(projectId, groupId) {
    return this.callWithAuth('/groups/details', {
      projectId,
      groupId
    })
  }

  async addGroupMember(projectId, groupId, userEmail, role = 'member') {
    return this.callWithAuth('/groups/add-member', {
      projectId,
      groupId,
      userEmail,
      role
    })
  }

  async removeGroupMember(projectId, groupId, userEmail) {
    return this.callWithAuth('/groups/remove-member', {
      projectId,
      groupId,
      userEmail
    })
  }

  async setGroupRole(projectId, groupId, groupRole, permissions = []) {
    return this.callWithAuth('/groups/set-role', {
      projectId,
      groupId,
      groupRole,
      permissions
    })
  }

  async getGroupMentionData(projectId, groupIds) {
    return this.callWithAuth('/groups/mention-data', {
      projectId,
      groupIds
    })
  }

  async getUserDisplayNames(projectId, userEmails) {
    return this.callWithAuth('/users/display-names', {
      projectId,
      userEmails
    })
  }

  // ========== Stage Management APIs ==========

  async createStage(projectId, stageData) {
    return this.callWithAuth('/stages/create', {
      projectId,
      stageData
    })
  }

  async getProjectStages(projectId) {
    return this.callWithAuth('/stages/list', {
      projectId
    })
  }

  async getStage(projectId, stageId) {
    return this.callWithAuth('/stages/get', {
      projectId,
      stageId
    })
  }

  async updateStage(projectId, stageId, updates) {
    return this.callWithAuth('/stages/update', {
      projectId,
      stageId,
      updates
    })
  }

  async updateStageConfig(projectId, stageId, configUpdates) {
    return this.callWithAuth('/stages/config', {
      projectId,
      stageId,
      configUpdates
    })
  }

  // ========== System/Admin APIs ==========

  async getSystemLogs(options = {}) {
    return this.callWithAuth('/system/logs', options)
  }

  async getLogStatistics() {
    return this.callWithAuth('/system/logs/stats')
  }

  async archiveLogs(maxRows = 50000) {
    return this.callWithAuth('/system/logs/archive', { maxRows })
  }

  // ========== Wallet APIs ==========

  async getWalletBalance(projectId, targetUserEmail = null) {
    return this.callWithAuth('/wallets/balance', { projectId, targetUserEmail })
  }

  async getWalletTransactions(projectId, targetUserEmail = null) {
    return this.callWithAuth('/wallets/transactions', { projectId, targetUserEmail })
  }

  async getWalletLeaderboard(projectId) {
    return this.callWithAuth('/wallets/leaderboard', { projectId })
  }

  async awardWalletPoints(projectId, targetUserEmail, amount, transactionType, source, relatedId = null, settlementId = null, stageId = null) {
    return this.callWithAuth('/wallets/award', {
      projectId,
      targetUserEmail,
      amount,
      transactionType,
      source,
      relatedId,
      settlementId,
      stageId
    })
  }

  // ========== Tag APIs ==========
  // DISABLED: Tags system has been disabled

  /* DISABLED - Tags system
  async createTag(tagData) {
    return this.callWithAuth('/tags/create', { tagData })
  }

  async updateTag(tagId, updates) {
    return this.callWithAuth('/tags/update', { tagId, updates })
  }

  async deleteTag(tagId) {
    return this.callWithAuth('/tags/delete', { tagId })
  }

  async assignTagToProject(projectId, tagId) {
    return this.callWithAuth('/tags/assign-project', { projectId, tagId })
  }

  async removeTagFromProject(projectId, tagId) {
    return this.callWithAuth('/tags/remove-project', { projectId, tagId })
  }
  */

  // ========== Invitation APIs ==========

  async generateInviteCodes(count, projectId = null) {
    return this.callWithAuth('/invitations/generate', { count, projectId })
  }

  async getInvitationCodes() {
    return this.callWithAuth('/invitations/list')
  }

  async validateInviteCode(inviteCode) {
    return this.call('/invitations/validate', { inviteCode }, 'GET')
  }
}

// Export singleton instance
export const apiClient = new APIClient()
export default apiClient
